# Dependencies
import streamlit as st
import pandas as pd
import itertools
from inform import Descriptions

def display_customer_dynammics():

    """
    display_customer_dynammics() brings every
    function together such that the code is 
    cleaner.
    """

    st.title("Transitional Probabilities")
    st.markdown('---')

    data = select_user_journey()

    if (data is not None):
        # Display Data
        display_data(data)

        # Finding Prob & Transforming into MDP Shape
        find_tuples(data)

    else: 
        st.markdown('---')
        st.warning('Before we start, you need to feed the algorithm some data!')

def select_user_journey():

    """
    select_user_journey() responsable for defining if the user 
    wants to drag and drop his data or if he wants to use data collected
    by the authors.
    """

    c1, c2 = st.columns((2, 1))
    c1.header('Input')

    c2.header('Description')
    c2.info(Descriptions.PROBABILITY_ABOUT)

    c2.error(Descriptions.PROBABILITY_INPUT)
    c2.success(Descriptions.PROBABILITY_OUTPUT)

    # Option to decide whether or not to use data generated by us
    data_options = ['Import own data', 'Use data collected by authors']
    option = c1.radio('Which data would you like the model to consider?', data_options)
    
    if (option == data_options[0]):

        # Own Data
        upload = c1.file_uploader("Upload CLV Data", type=["csv"], help = "Input should have a measure of user interection with action, e.g. email or call")
        #data = pd.read_csv("data/datasets/dummy/cart/weatherAUS 3.csv")

        if (upload is not None):
            data = pd.read_csv(upload).iloc[: , 1:]
            return data

    else:
        data = pd.read_csv('data/datasets/official/customer_dynamics/transitions_input.csv').iloc[: , 1:]
        return data

def find_tuples(data):

    """
    find_tuples(data) is responsable for 
    defining the transitional probabilities.
    """

    st.markdown('---')
    st.markdown('## Calculating Transition Probabilities')

    tuple_cols_target = st.multiselect("Select all columns (S,A) that should be transformed into a single Tuple", data.columns, key="tupler_transition")
    triple_cols_target = st.multiselect("Select all columns (S,A,S') that should be transformed into a single Tuple", data.columns, key="tripler_transition")

    if st.button('Create Tuples'):

        st.write('---')
        for tup in range(len(tuple_cols_target)):
            if (data[tuple_cols_target[tup]].dtype != object):
                data[tuple_cols_target[tup]] = data[tuple_cols_target[tup]].astype(str)

        for tri in range(len(triple_cols_target)):
            if (data[triple_cols_target[tri]].dtype != object):
                data[triple_cols_target[tri]] = data[triple_cols_target[tri]].astype(str)

        data["Tuple"] = data[tuple_cols_target].apply(tuple, axis = 1)
        data["Triple"] = data[triple_cols_target].apply(tuple, axis = 1)

        c1, c2 = st.columns([2, 1])

        c1.markdown('### Overview Occuring Combinations')
        c1.write(data)
        
        c2.markdown('### Time of Occurrences')
        c2.write(data["Triple"].value_counts())
        c2.write(data["Tuple"].value_counts())

        data["Number Tuples"] = data.groupby(['Tuple'])['state'].transform('count')

        data["Number Triples"] = data.groupby(['Triple'])['state'].transform('count')

        data = data.drop_duplicates(subset='Triple')

        data["Probability Triple"] =  data["Number Triples"] / data["Number Tuples"]

        # Union Definition
        unique_states = data["state"].explode().unique() 
        unique_states_star = data["follow_up_state"].explode().unique()
        # st.write('Union')

        state_list = Union(list(unique_states), list(unique_states_star))
        # st.write(state_list)

        # Unique Actions
        action_list = list(data['action'].explode().unique())
        # st.write(action_list)

        # Permutations
        set_perm = [state_list, action_list, state_list]
        permutations = list(itertools.product(*set_perm))
        transition_probabilities = pd.DataFrame(permutations, columns = ['state', 'action','follow_up_state'])

        # Encoding for fascility
        transition_probabilities["state_category"] = transition_probabilities["state"].astype('category').cat.codes
        transition_probabilities["state_category"].astype('int')
        transition_probabilities["action_category"] = transition_probabilities["action"].astype('category').cat.codes
        transition_probabilities["action_category"].astype('int')
        transition_probabilities["follow_up_state_category"] = transition_probabilities["follow_up_state"].astype('category').cat.codes
        transition_probabilities["follow_up_state_category"].astype('int')

        # Plotting Final Probabilities
        st.write('---')
        st.markdown('## Transition Probabilities')

        final_probabilies = pd.merge(data.copy(), transition_probabilities, how='outer')
        final_probabilies['Probability Triple'] = final_probabilies['Probability Triple'].fillna(0)

        # final_probabilies = final_probabilies.drop(['user', 'state', 'follow_up_state', 'Tuple', 'Triple', "Number Tuples", "Number Triples"], axis = 1)

        final_probabilies['Triple'] = final_probabilies[['state_category','action_category','follow_up_state_category']].apply(tuple, axis = 1)
        # final_probabilies = final_probabilies.drop_duplicates(subset=['Triple'])

        final_probabilies = final_probabilies.sort_values(['state_category', 'action_category', 'follow_up_state_category'])
        final_probabilies = final_probabilies.reset_index()
        final_probabilies = final_probabilies.drop(['index'], axis = 1)

        columns_titles = ["Triple","Probability Triple", 'state', 'state_category', 'action', 'action_category', 'follow_up_state', 'follow_up_state_category']
        final_probabilies = final_probabilies.reindex(columns=columns_titles)

        st.write(final_probabilies)

        csv = convert_df(final_probabilies)

        st.download_button(
            "Press to Download",
            csv,
            "probabilities_mdp.csv",
            "text/csv",
            key='rewards-csv'
        )

        return final_probabilies

def Union(lst1, lst2):
    """Return the union of two list as a list"""
    final_list = list(set(lst1) | set(lst2))
    return final_list

def display_data(data):
    st.markdown('---')
    st.write('## Data Overview')
    st.write(data)

@st.cache
def convert_df(df):
   return df.to_csv().encode('utf-8')